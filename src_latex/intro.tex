\section{Introduction}
\begin{quote}
\emph{``Any application that can be written in JavaScript, will eventually be written in JavaScript."} \newline --- Jeff Atwood ---
\end{quote}

JavaScript is a highly dynamic scripting programming language that is becoming one of the most important programming languages in the world. Recent surveys by Stack Overflow~\cite{so:survay2016} show JavaScript topping the rankings of popular programming languages for four years in a row. Many developers and companies are adopting JavaScript related technologies in production and it is the language with the largest number of active repositories and pushes on Github~\cite{githut}. JavaScript is dynamic, weakly-typed, and has first-class functions. It is a class-free, object-oriented programming language that uses prototypal inheritance instead of classical inheritance. Objects in JavaScript inherits properties from other objects directly and all these inherited properties can be changed at run-time~\cite{fard2013jsnose}. This trait can make JavaScript programs hard to maintain. Moreover, JavaScript being an interpreted language, developers are not equipped with a compiler that can help them spot erroneous and unoptimized code. As a consequence of all these characteristics, JavaScript applications often contain code smells~\cite{fowler1997refactoring}, \ie{} poor solutions to recurring design or implementation problems. However, despite the popularity of JavaScript, very few studies have investigated code smells in JavaScript applications, and to the best of our knowledge, there is no work that examines the impact of code smells on the fault-proneness {\color{blue}and on the vulnerability} of JavaScript applications. This paper aims to fill this gap in the literature. Specifically, we detect 12 types of code smells in in {\color{blue}1807} releases of {\color{blue}fifteen} popular JavaScript applications (\ie{} express, grunt, bower, less.js, request, {\color{blue}jquery, vue, ramda, leaflet, hexo, chart, webpack, webtorrent, moment, and riot}) and perform survival analysis, comparing the time until a fault occurrence, in files containing code smells and files without code smells. {\color{blue}We then do the same survival analysis, but with a line grain approach (wich means considering the lines where the code smells and the potential bugs appear), and with a line grain approach including dependencies (which means considering the lines where functions, objects, variables are called). We also perform file grain, line grain, and line grain including dependencies survival analysis, comparing the time until a vulnerability appears. Finally, we perform a survival analysis on code smells to know how long they survive.} We address the following {\color{blue}five} research questions:

\textbf{(RQ1) Is the risk of fault higher in files with code smells in comparison with those without code smell?}
Previous works~\cite{Khomh2012,jaafar2013mining} have found that code smells increase the risk of faults in Java classes. In this research question, we compare the time until a fault occurrence in JavaScript files that contain code smells and files without code smells, computing their respective hazard rates. Results show that on average, across our {\color{blue}fifteen} studied applications, JavaScript files without code smells have hazard rates {\color{blue}76\%} lower than files with code smells {\color{blue}in our file grain analysis, 20\% lower in our line grain analysis, and 38\% lower in our line grain analysis considering dependencies.}

\textbf{(RQ2) Are JavaScript files with code smells equally fault-prone?}
A major concern of developers interested in improving the design of their application is the prioritization of code and design issues that should be fixed, giving their limited resources. This research question examines faults in files affected by different types of code smells, with the aim to identify code smells that developers should refactor in priority. {\color{blue}We do this research through our file grain, line grain, and line grain including dependencies analysis.} Our findings show that ``Variable Re-assign", ``Assignment in Conditional Statements", {\color{blue}and ``Complex Code"} smells are consistently associated with high hazard rates across the {\color{blue}fifteen} studied systems. Developers should consider removing these code smells, in priority since they make the code more prone to faults. 
We also conducted a survey with 1,484 JavaScript developers, to understand the perception of developers towards the 12 studied code smells. Results show that developers consider ``Nested Callbacks", ``Variable Re-assign" and ``Long Parameter List" code smells to be the most hazardous code smells. Developers reported that these code smells negatively affect the maintainability and reliability of JavaScript applications.

{\color{blue}\textbf{(RQ3) Is the risk of vulnerability higher in files with code smells in comparison with those without code smell?}
Similarly to RQ1, we compare the time until a vulnerability appears in JavaScript files that contain code smells and files without code smells, computing their respective vulnerability hazard rates. Results show that on average, the risk of vulnerability is not higher in files with code smells in comparison with those without code smells. However, this conclusion has to be mitigated, especially because the vulnerabilities's database is not complete and presents a lack of accuracy.

\textbf{(RQ4) Are JavaScript files with code smells equally vulnerable?}
Similarly to RQ2, we examine vulnerabilities in files affected by different types of code smells, with the aim to identify code smells that developers should refactor in priority. Results show that ``Variable Re-assign" and ``This Assign" code smells tend to make the code more vulnerable than the other code smells, and thus should be removed in priority.

\textbf{(RQ5) How do the smells survive over time?}
It is interesting to know how long the smells of a project survive, when they are introduced (at the creation of a file or during a revision), and what type smell are likely to survive the most. Indeed, having a specific knowledge on the smells of a project could help us to determine what smell types are the most dangerous. Results show that smells are created at the file birthdate, and are persistant because a considerable proportion still survive today in the studied systems, and because they have a high chance to survive even a very long time after their introduction into the codebase. Especially, ``Variable Re-assign" is the most sizable code smells with one of the highest probability of surviving over time, and thereby we strongly recommend to developers to remove this code smells, at least to reduce their number. 
}

\textbf{The remainder of this paper is organized as follows.} Section \ref{sec:background} describes the type of code smells we used in our study.
Section~\ref{setup} describes the design of our case study. Section \ref{sec:case-study} presents and discusses the results of our case study. Section\ref{survey} presents and discusses the results of our qualitative study. Section~\ref{threats} discusses the limitation of our study. Section \ref{sec:related} discusses related works on code smells and JavaScript systems, while Section~\ref{conclusion} concludes the paper. 